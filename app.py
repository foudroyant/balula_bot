from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from dotenv import load_dotenv
import os
import logging

from binance import check_pay
from nocodb import addUser, get_one_user, getUsers, s_abonner, update_credits

from ocr import get_ocr_text
from remove_bg import transparent
from transcribe import transcription

# Charger les variables d'environnement
load_dotenv(encoding='utf-8')
TOKEN_BOT = os.getenv("TOKEN_BOT")
HOST = os.getenv("HOST")

work = 0  # RIEN A FAIRE
lang = "fr"

SUCCESS_URL = os.getenv("SUCCESS_URL")
CANCEL_URL = os.getenv("CANCEL_URL")


MESSAGE_INFO = '''# ü§ñ Balula - Votre Assistant de Saisie Intelligent üöÄ   

### üöÄ **Fonctionnalit√©s de Balula**  
‚úÖ **Transcription audio** : Convertissez vos messages vocaux en texte en quelques secondes.  
üñºÔ∏è **Extraction de texte depuis des images** : Utilisez la technologie OCR pour extraire du texte √† partir de photos.

### üí° √âvolutif et Am√©lior√© en Continu !  
Nous ajoutons r√©guli√®rement de nouvelles fonctionnalit√©s pour rendre **Balula** encore plus puissant.  

## üéÅ Version Gratuite  
üîπ Effectue toutes les op√©rations, mais avec quelques **limitations**.  

## üíé Plan PRO ‚Äì Seulement **10 ‚Ç¨ pour 3 mois** !  
üöÄ **Profitez sans limites** de toutes les fonctionnalit√©s de Balula :  
‚úîÔ∏è Transcriptions illimit√©es  
‚úîÔ∏è Extraction de texte illimit√©e   

---

### üñºÔ∏è **Extraction de Texte depuis une Image**  
Envoyez une image (screenshot, scan de document, photo, etc.), et **Balula** en extraira le texte.  
**Utilit√©s :**  
- **Professionnels** : Extrayez du texte √† partir de factures, de contrats ou de documents scann√©s.  
- **√âtudiants** : Num√©risez des livres ou des notes manuscrites.  
- **Archivage** : Convertissez des documents papier en fichiers texte num√©riques.  

---

### üí≥ **Modes de Paiement**  
Le paiement principal se fait par **cryptomonnaie** (Binance Pay ou TRON TRC-20).  
Si vous pr√©f√©rez un autre mode de paiement (comme **Mobile Money**), contactez notre service client √† üìß [contact@bambyno.com](mailto:contact@bambyno.com).  

### üì¢ Restez connect√©s !  
Des mises √† jour et de nouvelles fonctionnalit√©s arrivent bient√¥t. Essayez **Balula** d√®s maintenant !  
'''

MESSAGE_AIDE = '''# üìö Aide - Balula ü§ñ

Bienvenue dans le menu d'aide de **Balula** ! Voici un guide complet pour utiliser toutes les fonctionnalit√©s du bot :

---

### üéâ **Commandes Disponibles**  

üîπ **`/start`**  
- D√©marrer ou red√©marrer le bot.  
- Vous serez invit√© √† **choisir une langue** (le fran√ßais est la langue par d√©faut).  
- Une fois la langue s√©lectionn√©e, vous pouvez :  
  - Envoyer un **message vocal** pour le transcrire en texte.  
  - Envoyer une **image** (screenshot, scan de document, etc.) pour en extraire le texte.  

üîπ **`/help`**  
- Affiche ce menu d'aide pour vous guider dans l'utilisation du bot.  

üîπ **`/info`**  
- Obtenez des informations sur **Balula**, ses fonctionnalit√©s et les derni√®res nouveaut√©s (news).  

üîπ **`/me`**  
- Acc√©dez aux aux informations de votre compte, y compris le nombre de cr√©dits restants et l'√©tat de votre abonnement. 

üîπ **`/pay`**  
- Acc√©dez aux instructions pour passer au **Plan PRO** et profiter de toutes les fonctionnalit√©s sans limites.  

---

### üåç **Choix de la Langue**  
Apr√®s la commande `/start`, vous pouvez choisir une langue pour les transcriptions audio.  
- Si aucune langue n'est s√©lectionn√©e, le **fran√ßais** sera utilis√© par d√©faut.  
- Balula prend en charge de nombreuses langues pour r√©pondre √† vos besoins.  

---

### üéôÔ∏è **Transcription Audio**  
Envoyez un message vocal, et **Balula** le transcrira en texte en quelques secondes.  
**Utilit√©s :**  
- **Secr√©tariats** : Transcrivez rapidement des r√©unions, des notes vocales ou des instructions.  
- **Journalistes** : Transformez des interviews ou des reportages audio en texte pour vos articles.  
- **√âtudiants** : Convertissez des cours enregistr√©s en notes √©crites.  

---

### üí≥ **Modes de Paiement**  
Le paiement principal se fait par **cryptomonnaie** (Binance Pay ou TRON TRC-20).  
Si vous pr√©f√©rez un autre mode de paiement (comme **Mobile Money**), contactez notre service client √† üìß [contact@bambyno.com](mailto:contact@bambyno.com).  

---

### üåê **Notre Site Web**  
Pour plus d'informations, visitez notre site internet ‚û°Ô∏è [bambyno.com](https://www.bambyno.com)  

---

### üì¢ **Besoin d'Aide Suppl√©mentaire ?**  
Si vous avez des questions ou des probl√®mes, n'h√©sitez pas √† :  
1. Utiliser la commande **`/help`** pour consulter ce guide.  
2. Contacter notre service client √† üìß [contact@bambyno.com](mailto:contact@bambyno.com).  

Nous sommes l√† pour vous aider ! üòä    
'''


ID_BINANCE ='743559475'
TRX = "TMJ1g8PjfrrPCrkDdn9jHuwkhR1nzwnrAg"
MESSAGE_PAYEMENT_CRYPTO = f"""
üí≥ **Paiement via Binance ou autre plateforme de cryptomonnaie via le r√©seau TRON (TRC-20)** üí≥

Pour acc√©der √† toutes les fonctionnalit√©s de l'application, veuillez effectuer un paiement de **USDT pour 3 mois**.

Voici les informations de paiement :

üîπ **Binance ID** : `{ID_BINANCE}`
üîπ **Adresse TRX (TRC-20)** : `{TRX}`

‚ö†Ô∏è **Attention** :
- Assurez-vous de s√©lectionner le r√©seau **TRC-20** lors de l'envoi.
- V√©rifiez bien l'adresse avant de confirmer la transaction.

üì§ **Apr√®s le d√©p√¥t** :
Une fois la transaction effectu√©e, veuillez envoyer le **TxID** de la transaction ici pour valider votre paiement.

Merci pour votre confiance ! üòä
"""

DEJA_PRO ="""üéâ **F√©licitations !**  

Vous √™tes d√©j√† abonn√© au **Plan PRO** de Balula. üöÄ  

Avec votre abonnement, vous b√©n√©ficiez de :  
‚úÖ **Transcriptions audio illimit√©es**  
‚úÖ **Extraction de texte depuis des images** 

---

### üõ†Ô∏è **Rencontrez-vous un probl√®me ?**  
Si votre abonnement ne fonctionne pas correctement ou si vous avez des questions, voici ce que vous pouvez faire :  

1. **Red√©marrez le bot** en utilisant la commande `/start`.  
2. Si le probl√®me persiste, contactez notre **service client** √† üìß [contact@bambyno.com](mailto:contact@bambyno.com).  
   - N'oubliez pas de nous fournir des d√©tails sur le probl√®me rencontr√©.  

---

### üåê **Besoin d'Aide Suppl√©mentaire ?**  
Visitez notre site web pour plus d'informations : ‚û°Ô∏è [bambyno.com](https://www.bambyno.com)  

Nous sommes l√† pour vous aider ! üòä  """

def MESSAGE_GROS_FILE(msg_size=""):
    return f"""‚ö†Ô∏è **Limite de Taille des Fichiers & fonctionnalit√©s - Version FREE**  

Vous utilisez actuellement la **version FREE** de Balula. Avec cette version, vous pouvez envoyer des fichiers jusqu'√† **1 Mo maximum**.  

üîπ **Taille maximale autoris√©e** : 1 Mo  
{msg_size}
üîπ **Votre message vocal ne doit pas d√©passer **10 secondes** pour √™tre trait√©.** 
üîπ **Impossible de retirer des background des images**
üîπ **Cr√©dits maximal ** : 10

---

### üöÄ **Passez au Plan PRO pour Plus de Libert√© !**  
Avec le **Plan PRO**, vous b√©n√©ficiez de :  
‚úÖ **Taille de fichier illimit√©e**  
‚úÖ **Transcriptions audio illimit√©es**  
‚úÖ **Extraction de texte depuis des images** 

Pour passer au Plan PRO, utilisez la commande `/pay` ou contactez-nous √† üìß [contact@bambyno.com](mailto:contact@bambyno.com).  

---

### üîÑ **Vous pensez avoir d√©j√† pay√© ?**  
Si vous estimez avoir d√©j√† pay√© mais que vous rencontrez cette limitation :  
1. **Relancez la commande** `/start` pour actualiser votre statut.  
2. Si le probl√®me persiste, contactez notre **service client** √† üìß [contact@bambyno.com](mailto:contact@bambyno.com) en fournissant les d√©tails de votre paiement.  

---

### üåê **Besoin d'Aide ?**  
Visitez notre site web pour plus d'informations : ‚û°Ô∏è [bambyno.com](https://www.bambyno.com)  

Nous sommes l√† pour vous aider ! üòä  """


# Configurer le module logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def show_lng(lng):
    cases = {
        "fr": "Fran√ßais",
        "en": "Anglais",
        "pt": "Portugais",
        "es": "Espagnol"
    }
    return cases.get(lng, "fr")

def get_user_infos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """R√©cup√®re et affiche le num√©ro de t√©l√©phone de l'utilisateur"""
    contact = update.effective_user
    return {
        "user_id" : contact.id,
        "prenom" : contact.first_name,
        "nom" : contact.full_name,
        "username" : contact.username,
        "lang" : contact.language_code,
        "link" : contact.link
    }

# Fonction pour g√©rer la commande /start et afficher le menu
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    userID = user.id
    fullname = user.full_name
    username = user.username or "Inconnu"
    link = f"https://t.me/{username}" if username != "Inconnu" else "Aucun lien"
    langue = user.language_code

    _user = get_one_user(str(userID))
    if _user == None:
        addUser(userId=userID, fullname=fullname, link=link, username=username)
        await update.message.reply_text("Bienvenue ! Vous avez √™tes desormais membre.")
    else:
        context.user_data['user'] = _user
        context.user_data['type_account'] = _user["type"]
    
    if 'lang' not in context.user_data:
        context.user_data['lang'] = langue  # Valeur par d√©faut

    keyboard = [
        [InlineKeyboardButton("Fran√ßais", callback_data="fr"), InlineKeyboardButton("Espagnol", callback_data="es")],
        [InlineKeyboardButton("Anglais", callback_data="en"), InlineKeyboardButton("Portuguais", callback_data="pt")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(MESSAGE_AIDE, reply_markup=reply_markup, parse_mode="Markdown")

# Fonction pour g√©rer les interactions avec le menu
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    if 'lang' not in context.user_data:
        context.user_data['lang'] = 'fr'  # Valeur par d√©faut    
    
    if query.data in ["fr", "es", "en", "pt"]:
        context.user_data['lang'] = query.data
        await query.edit_message_text(text=f"Langue s√©lectionn√©e : {show_lng(context.user_data['lang'])}")

    if query.data == "copy_binance_id":
        await query.edit_message_text(f"`{ID_BINANCE}`", parse_mode="Markdown")
    
    if query.data == "copy_trx_address":
        await query.edit_message_text(f"`{TRX}`", parse_mode="Markdown")

    if query.data == "confirm":
        # Traiter la confirmation
        await query.edit_message_text(f"‚úÖ Transaction confirm√©e ! Nous allons v√©rifier le TxID `{context.user_data['txID']}` et activer votre acc√®s.", parse_mode="Markdown")
        # Ici, vous pouvez ajouter la logique pour valider le TxID et activer l'acc√®s
        pay = check_pay(context.user_data['txID'])
        if pay != None :
            print(pay)
            out = s_abonner(userID=update.effective_user.id, sessionID=context.user_data['txID'])
            if out is not None and pay['prix'] >=10 and pay["coin"] == 'USDT':
                # Si le paiement a r√©ussi
                await query.edit_message_text(
                    "‚úÖ Ce paiement a √©t√© effectu√© avec succ√®s ! Merci pour votre achat.\n\n"
                    "Si votre abonnement n'est pas encore pris en compte, veuillez relancer la commande `/start` pour actualiser votre statut.\n\n"
                    "Pour toute question, n'h√©sitez pas √† contacter notre service client √† l'adresse suivante : **contact@bambyno.com**.",
                    parse_mode="Markdown"
                )
            else:
                # Si le paiement n'a pas abouti
                await query.edit_message_text(
                    "‚ùå Le paiement n'a pas abouti.\n\n"
                    "Si vous pensez qu'il s'agit d'une erreur (peut-√™tre que le paiement n'est pas encore confirm√© sur la blockchain ou inferieur √† 10 USDT), veuillez contacter notre service client √† l'adresse suivante : **contact@bambyno.com**.\n\n"
                    "Nous vous remercions de votre patience et nous ferons de notre mieux pour r√©soudre ce probl√®me rapidement.",
                    parse_mode="Markdown"
                )
        else : 
            await query.edit_message_text(
                "‚ùå Aucun paiement correspondant √† ce TxID n'a √©t√© trouv√©.\n\n"
                "Si vous pensez qu'il s'agit d'une erreur, veuillez contacter notre service client √† l'adresse suivante : **contact@bambyno.com**.\n\n"
                "Merci de nous fournir une capture d'√©cran de la transaction pour que nous puissions r√©soudre ce probl√®me rapidement.\n\n"
                "Nous vous remercions de votre patience !",
                parse_mode="Markdown"
            )
        del context.user_data['txID']
        del context.user_data['moyen_pay']


    elif query.data == "cancel":
        # Annuler l'op√©ration
        await query.edit_message_text("‚ùå Transaction annul√©e. Si vous avez besoin d'aide, n'h√©sitez pas √† nous contacter.")
        # Supprimer le TxID stock√©
        if 'txID' in context.user_data:
            del context.user_data['txID']
            del context.user_data['moyen_pay']

# Fonction pour g√©rer la commande /info
async def infos(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    try :
        with open("cover.jpg", 'rb') as image_file:
            await update.message.reply_photo(photo=image_file, caption=MESSAGE_INFO, parse_mode='Markdown')
    except Exception as e:
        await update.message.reply_text(MESSAGE_INFO, parse_mode='Markdown')


# Fonction pour g√©rer la commande /aide
async def help(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    try :
        with open("cover.jpg", 'rb') as image_file:
            await update.message.reply_photo(photo=image_file, caption=MESSAGE_AIDE, parse_mode='Markdown')
    except Exception as e:
        await update.message.reply_text(MESSAGE_AIDE, parse_mode='Markdown')


async def Me(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    context.user_data['user'] = get_one_user(str(update.effective_user.id))
    
    print(context.user_data['user'])
    INFO = f"""üë§ **Informations de l'Utilisateur**  

    üîπ **Cr√©dits disponibles** : {context.user_data['user']["credits"]}  
    üîπ **Type de compte** : {context.user_data['user']["type"]}  
    üîπ **Date de paiement** : {context.user_data['user']["updatepro"]} 

    ### üöÄ **Que pouvez-vous faire ensuite ?**  
    - Utilisez vos cr√©dits pour transcrire des audios, extraire du texte d'images, ou supprimer des arri√®re-plans (en beta).  
    - Pour recharger vos cr√©dits ou mettre √† jour votre abonnement, utilisez la commande `/pay`.  

    Nous sommes l√† pour vous aider ! üòä  """ if context.user_data['user']["type"] == "PRO" else f"""üë§ **Informations de l'Utilisateur**  

    üîπ **Cr√©dits disponibles** : {context.user_data['user']["credits"]}  
    üîπ **Type de compte** : {context.user_data['user']["type"]}  

    Nous sommes l√† pour vous aider ! üòä  """
    await update.message.reply_text(INFO, parse_mode='Markdown')



# Fonction pour traiter les messages vocaux
async def handle_voice_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    file_id = update.message.voice.file_id  # R√©cup√©rer l'ID du fichier vocal
    file = await context.bot.get_file(file_id)  # Obtenir l'URL du fichier
    
    duration = update.message.voice.duration  # R√©cup√©rer la dur√©e du message vocal en secondes
    
    user = update.effective_user
    userID = user.id
    
    sent_message  = await update.message.reply_text("Veuillez patienter...")

    if 'user' not in context.user_data or 'credits' not in context.user_data:
        context.user_data['user'] = get_one_user(str(userID))  # R√©cup√©rer les donn√©es de l'utilisateur

    
    if  (context.user_data['user']["type"] == "FREE" and duration > 10 ) or context.user_data['user']["credits"] <= 0:
        await context.bot.delete_message(chat_id=update.message.chat_id, message_id=sent_message.message_id)
        await update.message.reply_text(MESSAGE_GROS_FILE(),
            parse_mode="Markdown"
        )
    
    else :   
        if 'lang' not in context.user_data:
            context.user_data['lang'] = 'fr'  # Valeur par d√©faut

        texte = transcription(file.file_path, context.user_data['lang'])

        # Envoyer le texte transcrit
        await context.bot.delete_message(chat_id=update.message.chat_id, message_id=sent_message.message_id)
        
        # Renvoyer l'audio avec la description
        await update.message.reply_audio(
            audio=file_id,  # ID du fichier audio
            caption=texte,  # Description de l'audio
            parse_mode="Markdown"
        )
        

    if int(context.user_data['user']["credits"]) > 0:
        update_credits(context.user_data['user']["Id"], int(context.user_data['user']["credits"]) - 1)
        context.user_data['user']["credits"] = int(context.user_data['user']["credits"]) - 1


# Fonction pour g√©rer les messages contenant des photos
async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # R√©cup√©rer le document envoy√©
    photo = update.message.photo[-1]

    # Obtenir la taille du fichier (en octets)
    photo_size_bytes = photo.file_size

    # Convertir la taille en kilo-octets (Ko) ou m√©ga-octets (Mo)
    photo_size_kb = photo_size_bytes / 1024  # Taille en Ko
    photo_size_mb = photo_size_kb / 1024     # Taille en Mo

    if 'user' not in context.user_data or 'credits' not in context.user_data:
        context.user_data['user'] = get_one_user(str(update.effective_user.id))  # R√©cup√©rer les donn√©es de l'utilisateur
    

    if photo_size_mb > 1 or context.user_data['user']["credits"] <= 0:
        await update.message.reply_text(MESSAGE_GROS_FILE(msg_size=f"üîπ **Taille de votre fichier** : {photo_size_mb} Mo"), parse_mode="Markdown")

    else : 
        photo_file = await update.message.photo[-1].get_file()
        file_path = f"downloads/{photo_file.file_id}.jpg"
        #await photo_file.download_to_drive(file_path)
        sent_message  = await update.message.reply_text("Veuillez patienter...")

        # R√©cup√©rer la l√©gende de l'image
        caption = update.message.caption
        if caption and caption.lower() == "remove" :
            if 'user' not in context.user_data:
                context.user_data['user'] = get_one_user(str(update.effective_user.id))  # R√©cup√©rer les donn√©es de l'utilisateur
            
            if  context.user_data['user']["type"] == "FREE" :
                await update.message.reply_text(MESSAGE_GROS_FILE(), parse_mode="Markdown")
            else :
                transparent(photo_file.file_path, photo_file.file_id)
                #await update.message.reply_text(f"L√©gende re√ßue : {caption}")
                with open(photo_file.file_id + ".png", 'rb') as image_file:
                    # Supprimer le message envoy√©
                    await context.bot.delete_message(chat_id=update.message.chat_id, message_id=sent_message.message_id)
                    await context.bot.send_photo(chat_id=update.message.chat_id, photo=image_file)
                    #await context.bot.send_document(chat_id=update.message.chat_id, document=image_file, caption="Voici votre image sans compr√©ssion !")

        else:
            # Utiliser la fonction getTexte pour traiter l'image
            ocr_response = get_ocr_text(photo_file.file_path)

            # Extraire le texte de toutes les pages
            texte_complet = "\n\n".join(page['markdown'] for page in ocr_response['pages'])
            await context.bot.delete_message(chat_id=update.message.chat_id, message_id=sent_message.message_id)
            if '![img-0.jpeg](img-0.jpeg)' in texte_complet :
                await update.message.reply_text(f"Difficile d'extraire le texte.")
            else : 
                await update.message.reply_photo(photo=photo_file.file_id, caption=f"{texte_complet}", parse_mode="Markdown")
    
    if int(context.user_data['user']["credits"]) > 0:
        update_credits(context.user_data['user']["Id"], int(context.user_data['user']["credits"]) - 1)
        context.user_data['user']["credits"] = int(context.user_data['user']["credits"]) - 1


# Fonction pour g√©rer les messages contenant des documents
async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # R√©cup√©rer le document envoy√©
    document = update.message.document

    # Obtenir le nom du fichier
    file_name = document.file_name

    # Extraire l'extension du fichier
    file_extension = os.path.splitext(file_name)[1]  # Par exemple : ".pdf"

    # Obtenir la taille du fichier (en octets)
    file_size_bytes = document.file_size

    # Convertir la taille en kilo-octets (Ko) ou m√©ga-octets (Mo)
    file_size_kb = file_size_bytes / 1024  # Taille en Ko
    file_size_mb = file_size_kb / 1024     # Taille en Mo

    if 'user' not in context.user_data or 'credits' not in context.user_data:
        context.user_data['user'] = get_one_user(str(update.effective_user.id))  # R√©cup√©rer les donn√©es de l'utilisateur

    if file_size_mb > 1 or context.user_data['user']["credits"] <= 0:
        await update.message.reply_text(MESSAGE_GROS_FILE(), parse_mode="Markdown")
    
    else :
        document_file = await update.message.document.get_file()
        file_path = f"downloads/{document_file.file_id}{file_extension}"
        #await document_file.download_to_drive(file_path)

        # Utiliser la fonction getTexte pour traiter l'image
        ocr_response = get_ocr_text(document_file.file_path)

        # Extraire le texte de toutes les pages
        texte_complet = "\n\n".join(page['markdown'] for page in ocr_response['pages'])
        await update.message.reply_text(f"{texte_complet}")
    
    
    if int(context.user_data['user']["credits"]) > 0:
        update_credits(context.user_data['user']["Id"], int(context.user_data['user']["credits"]) - 1)
        context.user_data['user']["credits"] = int(context.user_data['user']["credits"]) - 1


# Commande /pay pour d√©marrer le processus de paiement
'''async def pay(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id  # R√©cup√©rer l'ID utilisateur Telegram
    
    if 'user' not in context.user_data:
        context.user_data['user'] = get_one_user(str(user_id))

    if context.user_data['user']['type'] == "FREE" :
        try:
            # Cr√©ation de la session de paiement Stripe
            session = stripe.checkout.Session.create(
                payment_method_types=['card'],
                line_items=[{
                    'price_data': {
                        'currency': 'eur',
                        'product_data': {
                            'name': 'Balula PRO',
                        },
                        'unit_amount': 200,  # 2‚Ç¨
                    },
                    'quantity': 1,
                }],
                mode='payment',
                success_url=f"{HOST}/success?userid={user_id}&session_id={{CHECKOUT_SESSION_ID}}",
                cancel_url=f"{HOST}/cancel",
            )

            # Envoie du lien de paiement √† l'utilisateur
            await update.message.reply_text(
                f"üéâ **F√©licitations !** Vous √™tes √† un clic de finaliser votre paiement. üõçÔ∏è\n\n"
                f"üí≥ Cliquez sur le lien ci-dessous pour s√©curiser votre achat et profitez de notre offre exclusive ! üöÄ\n\n"
                f"üëâ [Proc√©der au paiement]({session.url})\n\n"
                f"‚úÖ Paiement rapide et s√©curis√© avec Stripe. N'attendez plus, votre achat vous attend ! üíºüí°",
                parse_mode='Markdown'
            )

        except Exception as e:
            await update.message.reply_text(f"Erreur lors de la cr√©ation de la session de paiement: {str(e)}")
    else : 
        await update.message.reply_text(f"Vous √™tes d√©j√† abonn√© √† notre service PRO !")
'''


async def pay_by_cripto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id  # R√©cup√©rer l'ID utilisateur Telegram

    if 'user' not in context.user_data:
        context.user_data['user'] = get_one_user(str(user_id))
        
    if context.user_data['user']['type'] == "FREE" :
        context.user_data['moyen_pay'] = "Binance"
        keyboard = [
            [
                InlineKeyboardButton("üìã ID Binance", callback_data="copy_binance_id"),
                InlineKeyboardButton("üìã Adresse TRX", callback_data="copy_trx_address")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        if 'user' not in context.user_data:
            context.user_data['user'] = get_one_user(str(user_id))
        # Envoyer le message en Markdown
        await update.message.reply_text(MESSAGE_PAYEMENT_CRYPTO, reply_markup=reply_markup, parse_mode="Markdown")
    else : 
        await update.message.reply_text(DEJA_PRO, parse_mode="Markdown")


# G√©rer la r√©ception du TxID
async def handle_txid(update: Update, context: ContextTypes.DEFAULT_TYPE):

    if 'user' not in context.user_data:
        context.user_data['user'] = get_one_user(str(update.effective_user.id))
        
    if context.user_data['user']['type'] == "FREE" :
        txid = update.message.text
        # Stocker le TxID temporairement
        context.user_data['txID'] = txid

        # Cr√©er les boutons inline
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ Confirmer", callback_data="confirm"),
                InlineKeyboardButton("‚ùå Annuler", callback_data="cancel")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # Demander confirmation √† l'utilisateur
        await update.message.reply_text(
            f"Vous avez envoy√© le TxID suivant : `{txid}`. Voulez-vous confirmer cette transaction ?",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
    else : await update.message.reply_text(DEJA_PRO, parse_mode="Markdown")
    
    
    
# Configuration du bot Telegram
app = ApplicationBuilder().token(TOKEN_BOT).build()

# Ajouter les handlers √† l'application Telegram
app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("info", infos))
app.add_handler(CommandHandler("help", help))
app.add_handler(CommandHandler("me", Me))
app.add_handler(CallbackQueryHandler(button_handler))
app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
app.add_handler(MessageHandler(filters.Document.MimeType("image/jpeg"), handle_document))
app.add_handler(MessageHandler(filters.VOICE, handle_voice_message))  # G√©rer les messages vocaux
#app.add_handler(CommandHandler("pay", pay))
app.add_handler(CommandHandler("pay", pay_by_cripto))

# G√©rer la r√©ception du TxID
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_txid))

app.run_polling(poll_interval=5)
